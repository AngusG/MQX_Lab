   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"AccelTask.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.comm	fd,4,4
  19              		.comm	recv_buffer,5,4
  20              		.comm	Sensor,7,4
  21              		.section	.rodata
  22              		.align	2
  23              	.LC0:
  24 0000 41636365 		.ascii	"Accel: X = %d, \000"
  24      6C3A2058 
  24      203D2025 
  24      642C2000 
  25              		.align	2
  26              	.LC1:
  27 0010 59203D20 		.ascii	"Y = %08d, \000"
  27      25303864 
  27      2C2000
  28 001b 00       		.align	2
  29              	.LC2:
  30 001c 5A203D20 		.ascii	"Z = %08d\015\012\000"
  30      25303864 
  30      0D0A00
  31              		.section	.text.print_accelerometer_data,"ax",%progbits
  32              		.align	2
  33              		.global	print_accelerometer_data
  34              		.thumb
  35              		.thumb_func
  37              	print_accelerometer_data:
  38              	.LFB0:
  39              		.file 1 "../Sources/AccelTask.c"
   1:../Sources/AccelTask.c **** /*
   2:../Sources/AccelTask.c ****  * AccelTask.c
   3:../Sources/AccelTask.c ****  *
   4:../Sources/AccelTask.c ****  *  Created on: Feb 6, 2014
   5:../Sources/AccelTask.c ****  *      Author: Embedded Access Inc
   6:../Sources/AccelTask.c ****  */
   7:../Sources/AccelTask.c **** 
   8:../Sources/AccelTask.c **** #include "main.h"
   9:../Sources/AccelTask.c **** #include <i2c.h>
  10:../Sources/AccelTask.c **** 
  11:../Sources/AccelTask.c **** #define I2C_ACCELEROMETER_ADDRESS   0x4C      //MMA7660
  12:../Sources/AccelTask.c **** #define I2C_DATA_SIZE               5
  13:../Sources/AccelTask.c **** 
  14:../Sources/AccelTask.c **** 
  15:../Sources/AccelTask.c **** FILE_PTR fd;
  16:../Sources/AccelTask.c **** unsigned char recv_buffer[I2C_DATA_SIZE];
  17:../Sources/AccelTask.c **** 
  18:../Sources/AccelTask.c **** void write_I2C(int i2c_device, unsigned char reg, unsigned char value);
  19:../Sources/AccelTask.c **** void read_I2C(int i2c_device, int sensor, int length);
  20:../Sources/AccelTask.c **** void print_accelerometer_data();
  21:../Sources/AccelTask.c **** signed char convert_accel_data(signed char input);
  22:../Sources/AccelTask.c **** void InitializeI2C();
  23:../Sources/AccelTask.c **** void InitializeMMA7660();
  24:../Sources/AccelTask.c **** 
  25:../Sources/AccelTask.c **** SENSOR_DATA Sensor;
  26:../Sources/AccelTask.c **** 
  27:../Sources/AccelTask.c **** /*TASK*-----------------------------------------------------
  28:../Sources/AccelTask.c **** * 
  29:../Sources/AccelTask.c **** * Task Name    : Accel_task
  30:../Sources/AccelTask.c **** * Comments     :
  31:../Sources/AccelTask.c **** *    This is the Accelerometer task
  32:../Sources/AccelTask.c **** *    From TWR-K60N512-UM User Manual v1.1
  33:../Sources/AccelTask.c **** *    Accelerometer:
  34:../Sources/AccelTask.c **** *    I2C SDA -> PTD9 = I2C0_SDA
  35:../Sources/AccelTask.c **** *    I2C SCL -> PTD8 = I2C0_SCL
  36:../Sources/AccelTask.c **** *    IRQ     -> PTD10 = PTD10    
  37:../Sources/AccelTask.c **** *
  38:../Sources/AccelTask.c **** *END*-----------------------------------------------------*/
  39:../Sources/AccelTask.c **** void print_accelerometer_data()
  40:../Sources/AccelTask.c **** {
  40              		.loc 1 40 0
  41              		.cfi_startproc
  42              		@ args = 0, pretend = 0, frame = 0
  43              		@ frame_needed = 1, uses_anonymous_args = 0
  44 0000 80B5     		push	{r7, lr}
  45              	.LCFI0:
  46              		.cfi_def_cfa_offset 8
  47              		.cfi_offset 7, -8
  48              		.cfi_offset 14, -4
  49 0002 00AF     		add	r7, sp, #0
  50              	.LCFI1:
  51              		.cfi_def_cfa_register 7
  41:../Sources/AccelTask.c ****    //MMA7660 Sensor
  42:../Sources/AccelTask.c **** 
  43:../Sources/AccelTask.c ****    printf("Accel: X = %d, ", Sensor.mma7660_x );
  52              		.loc 1 43 0
  53 0004 40F20003 		movw	r3, #:lower16:Sensor
  54 0008 C0F20003 		movt	r3, #:upper16:Sensor
  55 000c 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
  56 000e 40F20000 		movw	r0, #:lower16:.LC0
  57 0012 C0F20000 		movt	r0, #:upper16:.LC0
  58 0016 1946     		mov	r1, r3
  59 0018 FFF7FEFF 		bl	_io_printf
  44:../Sources/AccelTask.c ****    printf("Y = %08d, ", Sensor.mma7660_y );
  60              		.loc 1 44 0
  61 001c 40F20003 		movw	r3, #:lower16:Sensor
  62 0020 C0F20003 		movt	r3, #:upper16:Sensor
  63 0024 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
  64 0026 40F20000 		movw	r0, #:lower16:.LC1
  65 002a C0F20000 		movt	r0, #:upper16:.LC1
  66 002e 1946     		mov	r1, r3
  67 0030 FFF7FEFF 		bl	_io_printf
  45:../Sources/AccelTask.c ****    printf("Z = %08d\r\n", Sensor.mma7660_z );
  68              		.loc 1 45 0
  69 0034 40F20003 		movw	r3, #:lower16:Sensor
  70 0038 C0F20003 		movt	r3, #:upper16:Sensor
  71 003c 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
  72 003e 40F20000 		movw	r0, #:lower16:.LC2
  73 0042 C0F20000 		movt	r0, #:upper16:.LC2
  74 0046 1946     		mov	r1, r3
  75 0048 FFF7FEFF 		bl	_io_printf
  46:../Sources/AccelTask.c **** }
  76              		.loc 1 46 0
  77 004c 80BD     		pop	{r7, pc}
  78              		.cfi_endproc
  79              	.LFE0:
  81              		.section	.rodata
  82 0027 00       		.align	2
  83              	.LC3:
  84 0028 0A204163 		.ascii	"\012 Accel: Hello World \012\000"
  84      63656C3A 
  84      2048656C 
  84      6C6F2057 
  84      6F726C64 
  85              		.section	.text.Accel_task,"ax",%progbits
  86              		.align	2
  87              		.global	Accel_task
  88              		.thumb
  89              		.thumb_func
  91              	Accel_task:
  92              	.LFB1:
  47:../Sources/AccelTask.c **** 
  48:../Sources/AccelTask.c **** void Accel_task(uint32_t initial_data)
  49:../Sources/AccelTask.c **** {
  93              		.loc 1 49 0
  94              		.cfi_startproc
  95              		@ args = 0, pretend = 0, frame = 16
  96              		@ frame_needed = 1, uses_anonymous_args = 0
  97 0000 80B5     		push	{r7, lr}
  98              	.LCFI2:
  99              		.cfi_def_cfa_offset 8
 100              		.cfi_offset 7, -8
 101              		.cfi_offset 14, -4
 102 0002 84B0     		sub	sp, sp, #16
 103              	.LCFI3:
 104              		.cfi_def_cfa_offset 24
 105 0004 00AF     		add	r7, sp, #0
 106              	.LCFI4:
 107              		.cfi_def_cfa_register 7
 108 0006 7860     		str	r0, [r7, #4]
  50:../Sources/AccelTask.c **** 	_queue_id health_qid;
  51:../Sources/AccelTask.c **** 	APPLICATION_MESSAGE *msg;
  52:../Sources/AccelTask.c **** 	
  53:../Sources/AccelTask.c **** 	
  54:../Sources/AccelTask.c **** 	 /* initialize I2C driver */
  55:../Sources/AccelTask.c **** 	   InitializeI2C();
 109              		.loc 1 55 0
 110 0008 FFF7FEFF 		bl	InitializeI2C
  56:../Sources/AccelTask.c **** 
  57:../Sources/AccelTask.c **** 	   /* configure the MMA7660 */
  58:../Sources/AccelTask.c **** 	   InitializeMMA7660();
 111              		.loc 1 58 0
 112 000c FFF7FEFF 		bl	InitializeMMA7660
  59:../Sources/AccelTask.c **** 	
  60:../Sources/AccelTask.c **** 	printf("\n Accel: Hello World \n"); 
 113              		.loc 1 60 0
 114 0010 40F20000 		movw	r0, #:lower16:.LC3
 115 0014 C0F20000 		movt	r0, #:upper16:.LC3
 116 0018 FFF7FEFF 		bl	_io_printf
  61:../Sources/AccelTask.c **** 	
  62:../Sources/AccelTask.c **** 	//_task_block(); // Per Lab 5 requirements	
  63:../Sources/AccelTask.c **** 	health_qid = _msgq_get_id(0, HEALTH_QUEUE);		
 117              		.loc 1 63 0
 118 001c 4FF00000 		mov	r0, #0
 119 0020 4FF00101 		mov	r1, #1
 120 0024 FFF7FEFF 		bl	_msgq_get_id
 121 0028 0346     		mov	r3, r0
 122 002a FB81     		strh	r3, [r7, #14]	@ movhi
 123 002c 00E0     		b	.L4
 124              	.L5:
  64:../Sources/AccelTask.c **** 	while(1){		
  65:../Sources/AccelTask.c **** 		/* read first five registers on MMA7660 */
  66:../Sources/AccelTask.c **** 		      read_I2C( I2C_ACCELEROMETER_ADDRESS, 0x00, 5 );
  67:../Sources/AccelTask.c **** 		      
  68:../Sources/AccelTask.c **** 		      Sensor.mma7660_x = convert_accel_data( (uint8_t)recv_buffer[0] );
  69:../Sources/AccelTask.c **** 		      Sensor.mma7660_y = convert_accel_data( (uint8_t)recv_buffer[1] );
  70:../Sources/AccelTask.c **** 		      Sensor.mma7660_z = convert_accel_data( (uint8_t)recv_buffer[2] );
  71:../Sources/AccelTask.c **** 		      Sensor.mma7660_status = recv_buffer[3];
  72:../Sources/AccelTask.c **** 		      
  73:../Sources/AccelTask.c **** 		      print_accelerometer_data();   
  74:../Sources/AccelTask.c **** 		_time_delay(500);
  75:../Sources/AccelTask.c **** 		
  76:../Sources/AccelTask.c **** 		msg = _msg_alloc_system(sizeof(*msg));
  77:../Sources/AccelTask.c **** 		if( msg != NULL){
  78:../Sources/AccelTask.c **** 			msg->HEADER.TARGET_QID = health_qid;
  79:../Sources/AccelTask.c **** 			msg->MESSAGE_TYPE = ACCEL_MESSAGE;
  80:../Sources/AccelTask.c **** 			msg->DATA = 0;			
  81:../Sources/AccelTask.c **** 			_msgq_send(msg);
  82:../Sources/AccelTask.c **** 		}		
  83:../Sources/AccelTask.c **** 		//_sched_yield();
  84:../Sources/AccelTask.c **** 	}   
 125              		.loc 1 84 0
 126 002e 00BF     		nop
 127              	.L4:
  66:../Sources/AccelTask.c **** 		      read_I2C( I2C_ACCELEROMETER_ADDRESS, 0x00, 5 );
 128              		.loc 1 66 0
 129 0030 4FF04C00 		mov	r0, #76
 130 0034 4FF00001 		mov	r1, #0
 131 0038 4FF00502 		mov	r2, #5
 132 003c FFF7FEFF 		bl	read_I2C
  68:../Sources/AccelTask.c **** 		      Sensor.mma7660_x = convert_accel_data( (uint8_t)recv_buffer[0] );
 133              		.loc 1 68 0
 134 0040 40F20003 		movw	r3, #:lower16:recv_buffer
 135 0044 C0F20003 		movt	r3, #:upper16:recv_buffer
 136 0048 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 137 004a DBB2     		uxtb	r3, r3
 138 004c 5BB2     		sxtb	r3, r3
 139 004e 1846     		mov	r0, r3
 140 0050 FFF7FEFF 		bl	convert_accel_data
 141 0054 0346     		mov	r3, r0
 142 0056 DAB2     		uxtb	r2, r3
 143 0058 40F20003 		movw	r3, #:lower16:Sensor
 144 005c C0F20003 		movt	r3, #:upper16:Sensor
 145 0060 1A70     		strb	r2, [r3, #0]
  69:../Sources/AccelTask.c **** 		      Sensor.mma7660_y = convert_accel_data( (uint8_t)recv_buffer[1] );
 146              		.loc 1 69 0
 147 0062 40F20003 		movw	r3, #:lower16:recv_buffer
 148 0066 C0F20003 		movt	r3, #:upper16:recv_buffer
 149 006a 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 150 006c DBB2     		uxtb	r3, r3
 151 006e 5BB2     		sxtb	r3, r3
 152 0070 1846     		mov	r0, r3
 153 0072 FFF7FEFF 		bl	convert_accel_data
 154 0076 0346     		mov	r3, r0
 155 0078 DAB2     		uxtb	r2, r3
 156 007a 40F20003 		movw	r3, #:lower16:Sensor
 157 007e C0F20003 		movt	r3, #:upper16:Sensor
 158 0082 5A70     		strb	r2, [r3, #1]
  70:../Sources/AccelTask.c **** 		      Sensor.mma7660_z = convert_accel_data( (uint8_t)recv_buffer[2] );
 159              		.loc 1 70 0
 160 0084 40F20003 		movw	r3, #:lower16:recv_buffer
 161 0088 C0F20003 		movt	r3, #:upper16:recv_buffer
 162 008c 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 163 008e DBB2     		uxtb	r3, r3
 164 0090 5BB2     		sxtb	r3, r3
 165 0092 1846     		mov	r0, r3
 166 0094 FFF7FEFF 		bl	convert_accel_data
 167 0098 0346     		mov	r3, r0
 168 009a DAB2     		uxtb	r2, r3
 169 009c 40F20003 		movw	r3, #:lower16:Sensor
 170 00a0 C0F20003 		movt	r3, #:upper16:Sensor
 171 00a4 9A70     		strb	r2, [r3, #2]
  71:../Sources/AccelTask.c **** 		      Sensor.mma7660_status = recv_buffer[3];
 172              		.loc 1 71 0
 173 00a6 40F20003 		movw	r3, #:lower16:recv_buffer
 174 00aa C0F20003 		movt	r3, #:upper16:recv_buffer
 175 00ae DA78     		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 176 00b0 40F20003 		movw	r3, #:lower16:Sensor
 177 00b4 C0F20003 		movt	r3, #:upper16:Sensor
 178 00b8 DA70     		strb	r2, [r3, #3]
  73:../Sources/AccelTask.c **** 		      print_accelerometer_data();   
 179              		.loc 1 73 0
 180 00ba FFF7FEFF 		bl	print_accelerometer_data
  74:../Sources/AccelTask.c **** 		_time_delay(500);
 181              		.loc 1 74 0
 182 00be 4FF4FA70 		mov	r0, #500
 183 00c2 FFF7FEFF 		bl	_time_delay
  76:../Sources/AccelTask.c **** 		msg = _msg_alloc_system(sizeof(*msg));
 184              		.loc 1 76 0
 185 00c6 4FF01000 		mov	r0, #16
 186 00ca FFF7FEFF 		bl	_msg_alloc_system
 187 00ce B860     		str	r0, [r7, #8]
  77:../Sources/AccelTask.c **** 		if( msg != NULL){
 188              		.loc 1 77 0
 189 00d0 BB68     		ldr	r3, [r7, #8]
 190 00d2 002B     		cmp	r3, #0
 191 00d4 ABD0     		beq	.L5
  78:../Sources/AccelTask.c **** 			msg->HEADER.TARGET_QID = health_qid;
 192              		.loc 1 78 0
 193 00d6 BB68     		ldr	r3, [r7, #8]
 194 00d8 FA89     		ldrh	r2, [r7, #14]	@ movhi
 195 00da 5A80     		strh	r2, [r3, #2]	@ movhi
  79:../Sources/AccelTask.c **** 			msg->MESSAGE_TYPE = ACCEL_MESSAGE;
 196              		.loc 1 79 0
 197 00dc BB68     		ldr	r3, [r7, #8]
 198 00de 4FF00202 		mov	r2, #2
 199 00e2 1A72     		strb	r2, [r3, #8]
  80:../Sources/AccelTask.c **** 			msg->DATA = 0;			
 200              		.loc 1 80 0
 201 00e4 BB68     		ldr	r3, [r7, #8]
 202 00e6 4FF00002 		mov	r2, #0
 203 00ea DA60     		str	r2, [r3, #12]
  81:../Sources/AccelTask.c **** 			_msgq_send(msg);
 204              		.loc 1 81 0
 205 00ec B868     		ldr	r0, [r7, #8]
 206 00ee FFF7FEFF 		bl	_msgq_send
 207              		.loc 1 84 0
 208 00f2 9CE7     		b	.L5
 209              		.cfi_endproc
 210              	.LFE1:
 212              		.section	.rodata
 213 003f 00       		.align	2
 214              	.LC4:
 215 0040 69326330 		.ascii	"i2c0:\000"
 215      3A00
 216 0046 0000     		.align	2
 217              	.LC5:
 218 0048 4661696C 		.ascii	"Failed to open the I2C driver!\012\000"
 218      65642074 
 218      6F206F70 
 218      656E2074 
 218      68652049 
 219              		.section	.text.InitializeI2C,"ax",%progbits
 220              		.align	2
 221              		.global	InitializeI2C
 222              		.thumb
 223              		.thumb_func
 225              	InitializeI2C:
 226              	.LFB2:
  85:../Sources/AccelTask.c **** }
  86:../Sources/AccelTask.c **** void InitializeI2C()
  87:../Sources/AccelTask.c **** {
 227              		.loc 1 87 0
 228              		.cfi_startproc
 229              		@ args = 0, pretend = 0, frame = 0
 230              		@ frame_needed = 1, uses_anonymous_args = 0
 231 0000 80B5     		push	{r7, lr}
 232              	.LCFI5:
 233              		.cfi_def_cfa_offset 8
 234              		.cfi_offset 7, -8
 235              		.cfi_offset 14, -4
 236 0002 00AF     		add	r7, sp, #0
 237              	.LCFI6:
 238              		.cfi_def_cfa_register 7
  88:../Sources/AccelTask.c ****    /* Open the I2C driver, and assign a I2C device handler*/
  89:../Sources/AccelTask.c ****    fd = fopen ("i2c0:", NULL);
 239              		.loc 1 89 0
 240 0004 40F20000 		movw	r0, #:lower16:.LC4
 241 0008 C0F20000 		movt	r0, #:upper16:.LC4
 242 000c 4FF00001 		mov	r1, #0
 243 0010 FFF7FEFF 		bl	_io_fopen
 244 0014 0246     		mov	r2, r0
 245 0016 40F20003 		movw	r3, #:lower16:fd
 246 001a C0F20003 		movt	r3, #:upper16:fd
 247 001e 1A60     		str	r2, [r3, #0]
  90:../Sources/AccelTask.c ****    if (fd == NULL)
 248              		.loc 1 90 0
 249 0020 40F20003 		movw	r3, #:lower16:fd
 250 0024 C0F20003 		movt	r3, #:upper16:fd
 251 0028 1B68     		ldr	r3, [r3, #0]
 252 002a 002B     		cmp	r3, #0
 253 002c 0DD1     		bne	.L7
  91:../Sources/AccelTask.c ****    {
  92:../Sources/AccelTask.c ****       printf ("Failed to open the I2C driver!\n");
 254              		.loc 1 92 0
 255 002e 40F20000 		movw	r0, #:lower16:.LC5
 256 0032 C0F20000 		movt	r0, #:upper16:.LC5
 257 0036 FFF7FEFF 		bl	_io_printf
  93:../Sources/AccelTask.c ****       _time_delay (200L);
 258              		.loc 1 93 0
 259 003a 4FF0C800 		mov	r0, #200
 260 003e FFF7FEFF 		bl	_time_delay
  94:../Sources/AccelTask.c ****       _mqx_exit (1L);
 261              		.loc 1 94 0
 262 0042 4FF00100 		mov	r0, #1
 263 0046 FFF7FEFF 		bl	_mqx_exit
 264              	.L7:
  95:../Sources/AccelTask.c ****    }
  96:../Sources/AccelTask.c **** 
  97:../Sources/AccelTask.c ****    /* Set I2C into Master mode */
  98:../Sources/AccelTask.c ****    ioctl (fd, IO_IOCTL_I2C_SET_MASTER_MODE, NULL);
 265              		.loc 1 98 0
 266 004a 40F20003 		movw	r3, #:lower16:fd
 267 004e C0F20003 		movt	r3, #:upper16:fd
 268 0052 1B68     		ldr	r3, [r3, #0]
 269 0054 1846     		mov	r0, r3
 270 0056 40F20341 		movw	r1, #1027
 271 005a 4FF00002 		mov	r2, #0
 272 005e FFF7FEFF 		bl	_io_ioctl
  99:../Sources/AccelTask.c **** }
 273              		.loc 1 99 0
 274 0062 80BD     		pop	{r7, pc}
 275              		.cfi_endproc
 276              	.LFE2:
 278              		.section	.text.InitializeMMA7660,"ax",%progbits
 279              		.align	2
 280              		.global	InitializeMMA7660
 281              		.thumb
 282              		.thumb_func
 284              	InitializeMMA7660:
 285              	.LFB3:
 100:../Sources/AccelTask.c **** 
 101:../Sources/AccelTask.c **** void InitializeMMA7660()
 102:../Sources/AccelTask.c **** {
 286              		.loc 1 102 0
 287              		.cfi_startproc
 288              		@ args = 0, pretend = 0, frame = 0
 289              		@ frame_needed = 1, uses_anonymous_args = 0
 290 0000 80B5     		push	{r7, lr}
 291              	.LCFI7:
 292              		.cfi_def_cfa_offset 8
 293              		.cfi_offset 7, -8
 294              		.cfi_offset 14, -4
 295 0002 00AF     		add	r7, sp, #0
 296              	.LCFI8:
 297              		.cfi_def_cfa_register 7
 103:../Sources/AccelTask.c ****    /* Configure the MMA7660 */
 104:../Sources/AccelTask.c ****    write_I2C( I2C_ACCELEROMETER_ADDRESS, 0x09, 0xE0 );
 298              		.loc 1 104 0
 299 0004 4FF04C00 		mov	r0, #76
 300 0008 4FF00901 		mov	r1, #9
 301 000c 4FF0E002 		mov	r2, #224
 302 0010 FFF7FEFF 		bl	write_I2C
 105:../Sources/AccelTask.c ****    write_I2C( I2C_ACCELEROMETER_ADDRESS, 0x07, 0x19 );
 303              		.loc 1 105 0
 304 0014 4FF04C00 		mov	r0, #76
 305 0018 4FF00701 		mov	r1, #7
 306 001c 4FF01902 		mov	r2, #25
 307 0020 FFF7FEFF 		bl	write_I2C
 106:../Sources/AccelTask.c **** }
 308              		.loc 1 106 0
 309 0024 80BD     		pop	{r7, pc}
 310              		.cfi_endproc
 311              	.LFE3:
 313 0026 00BF     		.section	.text.write_I2C,"ax",%progbits
 314              		.align	2
 315              		.global	write_I2C
 316              		.thumb
 317              		.thumb_func
 319              	write_I2C:
 320              	.LFB4:
 107:../Sources/AccelTask.c **** 
 108:../Sources/AccelTask.c **** /* Function for writing data to I2C Sensor */
 109:../Sources/AccelTask.c **** void write_I2C(int i2c_device_address, unsigned char reg, unsigned char value)
 110:../Sources/AccelTask.c **** {
 321              		.loc 1 110 0
 322              		.cfi_startproc
 323              		@ args = 0, pretend = 0, frame = 16
 324              		@ frame_needed = 1, uses_anonymous_args = 0
 325 0000 80B5     		push	{r7, lr}
 326              	.LCFI9:
 327              		.cfi_def_cfa_offset 8
 328              		.cfi_offset 7, -8
 329              		.cfi_offset 14, -4
 330 0002 84B0     		sub	sp, sp, #16
 331              	.LCFI10:
 332              		.cfi_def_cfa_offset 24
 333 0004 00AF     		add	r7, sp, #0
 334              	.LCFI11:
 335              		.cfi_def_cfa_register 7
 336 0006 7860     		str	r0, [r7, #4]
 337 0008 1346     		mov	r3, r2
 338 000a 0A46     		mov	r2, r1
 339 000c FA70     		strb	r2, [r7, #3]
 340 000e BB70     		strb	r3, [r7, #2]
 111:../Sources/AccelTask.c ****    unsigned char data[2];
 112:../Sources/AccelTask.c **** 
 113:../Sources/AccelTask.c ****    data[0]=reg;   //Sensor register
 341              		.loc 1 113 0
 342 0010 FB78     		ldrb	r3, [r7, #3]
 343 0012 3B73     		strb	r3, [r7, #12]
 114:../Sources/AccelTask.c ****    data[1]=value; //Byte of data to write to register
 344              		.loc 1 114 0
 345 0014 BB78     		ldrb	r3, [r7, #2]
 346 0016 7B73     		strb	r3, [r7, #13]
 115:../Sources/AccelTask.c **** 
 116:../Sources/AccelTask.c ****    /* Set the destination address */
 117:../Sources/AccelTask.c ****    ioctl (fd, IO_IOCTL_I2C_SET_DESTINATION_ADDRESS, &i2c_device_address);
 347              		.loc 1 117 0
 348 0018 40F20003 		movw	r3, #:lower16:fd
 349 001c C0F20003 		movt	r3, #:upper16:fd
 350 0020 1A68     		ldr	r2, [r3, #0]
 351 0022 07F10403 		add	r3, r7, #4
 352 0026 1046     		mov	r0, r2
 353 0028 4FF48161 		mov	r1, #1032
 354 002c 1A46     		mov	r2, r3
 355 002e FFF7FEFF 		bl	_io_ioctl
 118:../Sources/AccelTask.c **** 
 119:../Sources/AccelTask.c ****    /* Write 2 bytes of data: the desired register and then the data */
 120:../Sources/AccelTask.c ****    fwrite (&data, 1, 2, fd);  //data to write, size of unit, # of bytes to write, I2C device handle
 356              		.loc 1 120 0
 357 0032 40F20003 		movw	r3, #:lower16:fd
 358 0036 C0F20003 		movt	r3, #:upper16:fd
 359 003a 1A68     		ldr	r2, [r3, #0]
 360 003c 07F10C03 		add	r3, r7, #12
 361 0040 1046     		mov	r0, r2
 362 0042 1946     		mov	r1, r3
 363 0044 4FF00202 		mov	r2, #2
 364 0048 FFF7FEFF 		bl	_io_write
 121:../Sources/AccelTask.c ****    fflush (fd);
 365              		.loc 1 121 0
 366 004c 40F20003 		movw	r3, #:lower16:fd
 367 0050 C0F20003 		movt	r3, #:upper16:fd
 368 0054 1B68     		ldr	r3, [r3, #0]
 369 0056 1846     		mov	r0, r3
 370 0058 FFF7FEFF 		bl	_io_fflush
 122:../Sources/AccelTask.c **** 
 123:../Sources/AccelTask.c ****    /* Send out stop */
 124:../Sources/AccelTask.c ****    ioctl (fd, IO_IOCTL_I2C_STOP, NULL);
 371              		.loc 1 124 0
 372 005c 40F20003 		movw	r3, #:lower16:fd
 373 0060 C0F20003 		movt	r3, #:upper16:fd
 374 0064 1B68     		ldr	r3, [r3, #0]
 375 0066 1846     		mov	r0, r3
 376 0068 40F20C41 		movw	r1, #1036
 377 006c 4FF00002 		mov	r2, #0
 378 0070 FFF7FEFF 		bl	_io_ioctl
 125:../Sources/AccelTask.c **** }
 379              		.loc 1 125 0
 380 0074 07F11007 		add	r7, r7, #16
 381 0078 BD46     		mov	sp, r7
 382 007a 80BD     		pop	{r7, pc}
 383              		.cfi_endproc
 384              	.LFE4:
 386              		.section	.text.read_I2C,"ax",%progbits
 387              		.align	2
 388              		.global	read_I2C
 389              		.thumb
 390              		.thumb_func
 392              	read_I2C:
 393              	.LFB5:
 126:../Sources/AccelTask.c **** 
 127:../Sources/AccelTask.c **** /* Function for reading data from I2C. Data placed in recv_buffer */
 128:../Sources/AccelTask.c **** void read_I2C(int i2c_device_address, int sensor, int length)
 129:../Sources/AccelTask.c **** {
 394              		.loc 1 129 0
 395              		.cfi_startproc
 396              		@ args = 0, pretend = 0, frame = 24
 397              		@ frame_needed = 1, uses_anonymous_args = 0
 398 0000 80B5     		push	{r7, lr}
 399              	.LCFI12:
 400              		.cfi_def_cfa_offset 8
 401              		.cfi_offset 7, -8
 402              		.cfi_offset 14, -4
 403 0002 86B0     		sub	sp, sp, #24
 404              	.LCFI13:
 405              		.cfi_def_cfa_offset 32
 406 0004 00AF     		add	r7, sp, #0
 407              	.LCFI14:
 408              		.cfi_def_cfa_register 7
 409 0006 F860     		str	r0, [r7, #12]
 410 0008 B960     		str	r1, [r7, #8]
 411 000a 7A60     		str	r2, [r7, #4]
 130:../Sources/AccelTask.c ****    int n = length;
 412              		.loc 1 130 0
 413 000c 7B68     		ldr	r3, [r7, #4]
 414 000e 7B61     		str	r3, [r7, #20]
 131:../Sources/AccelTask.c **** 
 132:../Sources/AccelTask.c ****    /* the starting register for the particular sensor requested */
 133:../Sources/AccelTask.c ****    unsigned char reg=sensor;
 415              		.loc 1 133 0
 416 0010 BB68     		ldr	r3, [r7, #8]
 417 0012 DBB2     		uxtb	r3, r3
 418 0014 FB74     		strb	r3, [r7, #19]
 134:../Sources/AccelTask.c **** 
 135:../Sources/AccelTask.c ****    /* set the I2C destination address */
 136:../Sources/AccelTask.c ****    ioctl( fd, IO_IOCTL_I2C_SET_DESTINATION_ADDRESS, &i2c_device_address );
 419              		.loc 1 136 0
 420 0016 40F20003 		movw	r3, #:lower16:fd
 421 001a C0F20003 		movt	r3, #:upper16:fd
 422 001e 1A68     		ldr	r2, [r3, #0]
 423 0020 07F10C03 		add	r3, r7, #12
 424 0024 1046     		mov	r0, r2
 425 0026 4FF48161 		mov	r1, #1032
 426 002a 1A46     		mov	r2, r3
 427 002c FFF7FEFF 		bl	_io_ioctl
 137:../Sources/AccelTask.c **** 
 138:../Sources/AccelTask.c ****    /* tell the QE96 which sensor data to get */
 139:../Sources/AccelTask.c ****    fwrite( &reg, 1, 1, fd); //data to write, size of unit, # of bytes to write, I2C device handl er
 428              		.loc 1 139 0
 429 0030 40F20003 		movw	r3, #:lower16:fd
 430 0034 C0F20003 		movt	r3, #:upper16:fd
 431 0038 1A68     		ldr	r2, [r3, #0]
 432 003a 07F11303 		add	r3, r7, #19
 433 003e 1046     		mov	r0, r2
 434 0040 1946     		mov	r1, r3
 435 0042 4FF00102 		mov	r2, #1
 436 0046 FFF7FEFF 		bl	_io_write
 140:../Sources/AccelTask.c **** 
 141:../Sources/AccelTask.c ****    /* wait for completion */
 142:../Sources/AccelTask.c ****    fflush( fd );
 437              		.loc 1 142 0
 438 004a 40F20003 		movw	r3, #:lower16:fd
 439 004e C0F20003 		movt	r3, #:upper16:fd
 440 0052 1B68     		ldr	r3, [r3, #0]
 441 0054 1846     		mov	r0, r3
 442 0056 FFF7FEFF 		bl	_io_fflush
 143:../Sources/AccelTask.c **** 
 144:../Sources/AccelTask.c ****    /* do a repeated start to avoid giving up control */
 145:../Sources/AccelTask.c ****    ioctl( fd, IO_IOCTL_I2C_REPEATED_START, NULL );
 443              		.loc 1 145 0
 444 005a 40F20003 		movw	r3, #:lower16:fd
 445 005e C0F20003 		movt	r3, #:upper16:fd
 446 0062 1B68     		ldr	r3, [r3, #0]
 447 0064 1846     		mov	r0, r3
 448 0066 40F20B41 		movw	r1, #1035
 449 006a 4FF00002 		mov	r2, #0
 450 006e FFF7FEFF 		bl	_io_ioctl
 146:../Sources/AccelTask.c **** 
 147:../Sources/AccelTask.c ****    /* set how many bytes to read */
 148:../Sources/AccelTask.c ****    ioctl( fd, IO_IOCTL_I2C_SET_RX_REQUEST, &n );
 451              		.loc 1 148 0
 452 0072 40F20003 		movw	r3, #:lower16:fd
 453 0076 C0F20003 		movt	r3, #:upper16:fd
 454 007a 1A68     		ldr	r2, [r3, #0]
 455 007c 07F11403 		add	r3, r7, #20
 456 0080 1046     		mov	r0, r2
 457 0082 40F20A41 		movw	r1, #1034
 458 0086 1A46     		mov	r2, r3
 459 0088 FFF7FEFF 		bl	_io_ioctl
 149:../Sources/AccelTask.c **** 
 150:../Sources/AccelTask.c ****    /*
 151:../Sources/AccelTask.c ****     * read n bytes of data and put it into the recv_buffer
 152:../Sources/AccelTask.c ****     * buffer to read data into, size of unit, # of bytes to read, I2C device handler
 153:../Sources/AccelTask.c ****     */
 154:../Sources/AccelTask.c ****    fread( &recv_buffer, 1, n, fd );
 460              		.loc 1 154 0
 461 008c 40F20003 		movw	r3, #:lower16:fd
 462 0090 C0F20003 		movt	r3, #:upper16:fd
 463 0094 1A68     		ldr	r2, [r3, #0]
 464 0096 7B69     		ldr	r3, [r7, #20]
 465 0098 1046     		mov	r0, r2
 466 009a 40F20001 		movw	r1, #:lower16:recv_buffer
 467 009e C0F20001 		movt	r1, #:upper16:recv_buffer
 468 00a2 1A46     		mov	r2, r3
 469 00a4 FFF7FEFF 		bl	_io_read
 155:../Sources/AccelTask.c **** 
 156:../Sources/AccelTask.c ****    /* wait for completion */
 157:../Sources/AccelTask.c ****    fflush( fd );
 470              		.loc 1 157 0
 471 00a8 40F20003 		movw	r3, #:lower16:fd
 472 00ac C0F20003 		movt	r3, #:upper16:fd
 473 00b0 1B68     		ldr	r3, [r3, #0]
 474 00b2 1846     		mov	r0, r3
 475 00b4 FFF7FEFF 		bl	_io_fflush
 158:../Sources/AccelTask.c **** 
 159:../Sources/AccelTask.c ****    /* send out stop */
 160:../Sources/AccelTask.c ****    ioctl( fd, IO_IOCTL_I2C_STOP, NULL );
 476              		.loc 1 160 0
 477 00b8 40F20003 		movw	r3, #:lower16:fd
 478 00bc C0F20003 		movt	r3, #:upper16:fd
 479 00c0 1B68     		ldr	r3, [r3, #0]
 480 00c2 1846     		mov	r0, r3
 481 00c4 40F20C41 		movw	r1, #1036
 482 00c8 4FF00002 		mov	r2, #0
 483 00cc FFF7FEFF 		bl	_io_ioctl
 161:../Sources/AccelTask.c **** }
 484              		.loc 1 161 0
 485 00d0 07F11807 		add	r7, r7, #24
 486 00d4 BD46     		mov	sp, r7
 487 00d6 80BD     		pop	{r7, pc}
 488              		.cfi_endproc
 489              	.LFE5:
 491              		.section	.text.convert_accel_data,"ax",%progbits
 492              		.align	2
 493              		.global	convert_accel_data
 494              		.thumb
 495              		.thumb_func
 497              	convert_accel_data:
 498              	.LFB6:
 162:../Sources/AccelTask.c **** // ===  FUNCTION  ======================================================================
 163:../Sources/AccelTask.c **** //         Name:  convert_accel_data
 164:../Sources/AccelTask.c **** /**
 165:../Sources/AccelTask.c ****  * @brief Convert 6-bit result into an 8-bit signed char
 166:../Sources/AccelTask.c ****  *
 167:../Sources/AccelTask.c ****  * @param signed char
 168:../Sources/AccelTask.c ****  * 
 169:../Sources/AccelTask.c ****  * @return signed char
 170:../Sources/AccelTask.c ****  */
 171:../Sources/AccelTask.c **** // =====================================================================================
 172:../Sources/AccelTask.c **** signed char convert_accel_data ( signed char byte )
 173:../Sources/AccelTask.c **** {
 499              		.loc 1 173 0
 500              		.cfi_startproc
 501              		@ args = 0, pretend = 0, frame = 8
 502              		@ frame_needed = 1, uses_anonymous_args = 0
 503              		@ link register save eliminated.
 504 0000 80B4     		push	{r7}
 505              	.LCFI15:
 506              		.cfi_def_cfa_offset 4
 507              		.cfi_offset 7, -4
 508 0002 83B0     		sub	sp, sp, #12
 509              	.LCFI16:
 510              		.cfi_def_cfa_offset 16
 511 0004 00AF     		add	r7, sp, #0
 512              	.LCFI17:
 513              		.cfi_def_cfa_register 7
 514 0006 0346     		mov	r3, r0
 515 0008 FB71     		strb	r3, [r7, #7]
 174:../Sources/AccelTask.c ****    byte &= ~0x40;       // Turn off alert bit
 516              		.loc 1 174 0
 517 000a FB79     		ldrb	r3, [r7, #7]
 518 000c 23F04003 		bic	r3, r3, #64
 519 0010 FB71     		strb	r3, [r7, #7]
 175:../Sources/AccelTask.c ****    if( byte & 0x20 ) {  // update 6-bit signed format to 8-bit signed format
 520              		.loc 1 175 0
 521 0012 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 522 0014 03F02003 		and	r3, r3, #32
 523 0018 002B     		cmp	r3, #0
 524 001a 03D0     		beq	.L12
 176:../Sources/AccelTask.c ****       byte |= 0xE0;
 525              		.loc 1 176 0
 526 001c FB79     		ldrb	r3, [r7, #7]
 527 001e 63F01F03 		orn	r3, r3, #31
 528 0022 FB71     		strb	r3, [r7, #7]
 529              	.L12:
 177:../Sources/AccelTask.c ****    }
 178:../Sources/AccelTask.c ****    return( byte );
 530              		.loc 1 178 0
 531 0024 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 532 0026 5BB2     		sxtb	r3, r3
 179:../Sources/AccelTask.c **** }      /* -----  end of function convert_accel_data  ----- */
 533              		.loc 1 179 0
 534 0028 1846     		mov	r0, r3
 535 002a 07F10C07 		add	r7, r7, #12
 536 002e BD46     		mov	sp, r7
 537 0030 80BC     		pop	{r7}
 538 0032 7047     		bx	lr
 539              		.cfi_endproc
 540              	.LFE6:
 542              		.text
 543              	.Letext0:
 544              		.file 2 "C:/Freescale/CW MCU v10.6/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 545              		.file 3 "C:/Freescale/Freescale_MQX_4_1/lib/twrk60n512.cw10gcc/debug/psp/psptypes.h"
 546              		.file 4 "C:/Freescale/Freescale_MQX_4_1/lib/twrk60n512.cw10gcc/debug/psp/queue.h"
 547              		.file 5 "C:/Freescale/Freescale_MQX_4_1/lib/twrk60n512.cw10gcc/debug/psp/fio.h"
 548              		.file 6 "C:/Freescale/Freescale_MQX_4_1/lib/twrk60n512.cw10gcc/debug/psp/io.h"
 549              		.file 7 "C:/Freescale/Freescale_MQX_4_1/lib/twrk60n512.cw10gcc/debug/psp/message.h"
 550              		.file 8 "../Sources/main.h"
DEFINED SYMBOLS
                            *ABS*:00000000 AccelTask.c
                            *COM*:00000004 fd
                            *COM*:00000005 recv_buffer
                            *COM*:00000007 Sensor
C:\Users\Angus\AppData\Local\Temp\ccjBIDaa.s:22     .rodata:00000000 $d
C:\Users\Angus\AppData\Local\Temp\ccjBIDaa.s:23     .rodata:00000000 .LC0
C:\Users\Angus\AppData\Local\Temp\ccjBIDaa.s:26     .rodata:00000010 .LC1
C:\Users\Angus\AppData\Local\Temp\ccjBIDaa.s:29     .rodata:0000001c .LC2
C:\Users\Angus\AppData\Local\Temp\ccjBIDaa.s:32     .text.print_accelerometer_data:00000000 $t
C:\Users\Angus\AppData\Local\Temp\ccjBIDaa.s:37     .text.print_accelerometer_data:00000000 print_accelerometer_data
C:\Users\Angus\AppData\Local\Temp\ccjBIDaa.s:83     .rodata:00000028 .LC3
C:\Users\Angus\AppData\Local\Temp\ccjBIDaa.s:86     .text.Accel_task:00000000 $t
C:\Users\Angus\AppData\Local\Temp\ccjBIDaa.s:91     .text.Accel_task:00000000 Accel_task
C:\Users\Angus\AppData\Local\Temp\ccjBIDaa.s:225    .text.InitializeI2C:00000000 InitializeI2C
C:\Users\Angus\AppData\Local\Temp\ccjBIDaa.s:284    .text.InitializeMMA7660:00000000 InitializeMMA7660
C:\Users\Angus\AppData\Local\Temp\ccjBIDaa.s:392    .text.read_I2C:00000000 read_I2C
C:\Users\Angus\AppData\Local\Temp\ccjBIDaa.s:497    .text.convert_accel_data:00000000 convert_accel_data
C:\Users\Angus\AppData\Local\Temp\ccjBIDaa.s:214    .rodata:00000040 .LC4
C:\Users\Angus\AppData\Local\Temp\ccjBIDaa.s:217    .rodata:00000048 .LC5
C:\Users\Angus\AppData\Local\Temp\ccjBIDaa.s:220    .text.InitializeI2C:00000000 $t
C:\Users\Angus\AppData\Local\Temp\ccjBIDaa.s:279    .text.InitializeMMA7660:00000000 $t
C:\Users\Angus\AppData\Local\Temp\ccjBIDaa.s:319    .text.write_I2C:00000000 write_I2C
C:\Users\Angus\AppData\Local\Temp\ccjBIDaa.s:314    .text.write_I2C:00000000 $t
C:\Users\Angus\AppData\Local\Temp\ccjBIDaa.s:387    .text.read_I2C:00000000 $t
C:\Users\Angus\AppData\Local\Temp\ccjBIDaa.s:492    .text.convert_accel_data:00000000 $t
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_io_printf
_msgq_get_id
_time_delay
_msg_alloc_system
_msgq_send
_io_fopen
_mqx_exit
_io_ioctl
_io_write
_io_fflush
_io_read
